{"noir_version":"0.24.0+9544813fabbd18a87dd88456e6a5b781bd0cf008","hash":16143827226227759932,"abi":{"parameters":[{"name":"id_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"id_trapdoor","type":{"kind":"field"},"visibility":"private"},{"name":"siblings","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"indices","type":{"kind":"field"},"visibility":"private"},{"name":"external_nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"public"},{"name":"signal_hash","type":{"kind":"field"},"visibility":"public"}],"param_witnesses":{"external_nullifier":[{"start":19,"end":20}],"id_nullifier":[{"start":0,"end":1}],"id_trapdoor":[{"start":1,"end":2}],"indices":[{"start":18,"end":19}],"nullifier_hash":[{"start":21,"end":22}],"root":[{"start":20,"end":21}],"siblings":[{"start":2,"end":18}],"signal_hash":[{"start":22,"end":23}]},"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"7d1daxpBFIfx77LXXuzMnH3zq5Rc2DaFQDAhSqGI373aquR/qvYiHTja5y7CmM7+KGcfhiW7aZ5fvizWTy/LVTPfNG0z/7RpVq+L5f7Tar14WzfzqZRZ87j8uvtpbLez5tvT82Mzt347+2NpHofD0pLH09I8nVlqKfeHtZYsX1+ch/G4hzy2dn3xNHSHtanNsvZh1qS7v8J891dYzl1hatv+9JVit36N9h9cY3f2GnN33Hcq6W//V7v2tJV0fWnq0/HXju842v1G+igbGaJsZIyykSnKRlIbZicpzE5ymJ2UMDuxMDsJM19TmAGbwkzYFGbEpjAzNoeZsTnMjM1hZmwOM2NzmBmbw8zYHGbG5jAzNoeZsTnMjC1hZmwJM2NLmBlbwszYEmbGljAztoSZseXjM9a605lPP75fuv/1Hx+cXZ8Pa/u22976ieOEh5xOtniIR8JDPDIe4lHwEA/DQzy6qrdz6+EW7gEP8SD31IPcE4+O3FMPck89yD31KFVv553BLdwdHuJB7qkHuace5J56kHvi0ZN76pGq3s576km5OSxTD8NDPMg99SD31IPcUw9yTz2mqrfzgXoS7oHDMvUg99SD3FMPw0M8yD31IPfUo+6jcAP1pNwclonHSO6pB7mnHuSeepB76mF4iEfdR+FG6km5OSxTD3JPPcg98ZjIPfUg99SD3FOPuo/CTQa3cHNYph7knnqQe+pB7qkHuSceqaX3HEjdh+F2/yTgCs6BmQMxQBSE6HMgVJ8DIfscCN3nQOo+FJcSHaXgiYMzB0L4ORDCz4EYIApC+DkQws+BDJVv63SUA+cATUEy4edACD8HQvg5EMLPgRggClL3IbmU6SgHzgGaAyH8HAjhpyCF8HMghJ8DIfwcSN2H5dI/+Jv+dwbOAZoDIfwcCOHnQAg/B0L4KQgvh/AglR+Z420LHpwDNAdigCgI4edACD8HQvg5EMLPgVR+ZI63LjhwXrvgQQg/B0L4ORADREEIPwdC+DmQyo/M8fYFD84BmoLw/gUPQvg5EMLPgRB+DsQAUZAL4WfTBZBfXzofRzbZ8UudjbdPc754bOgvXOXD7sP3xdvT4vPz42r3ld3H9Y/X3z9ufwI=","file_map":{"20":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"29":{"source":"global RATE = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n\n    pub fn hash<N>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<N>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i as u32 < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"std/hash/poseidon2.nr"},"46":{"source":"use dep::std::hash::poseidon2::Poseidon2;\n\nglobal LEVELS: Field = 16;\n\n// same as stds::merkle::compute_merkle_root but using poseidon hash\nfn compute_merkle_root(leaf: Field, index: Field, hash_path: [Field; LEVELS]) -> Field {\n    let index_bits = index.to_le_bits(LEVELS as u32);\n    let mut current = leaf;\n    for i in 0..(LEVELS as u32) {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n\n        current = Poseidon2::hash([hash_left, hash_right], 2);\n    }\n    current\n}\n\nfn main(\n    id_nullifier: Field,\n    id_trapdoor: Field,\n    siblings: [Field; LEVELS],\n    indices: Field,\n    external_nullifier: pub Field,\n    root: pub Field,\n    nullifier_hash: pub Field,\n    signal_hash: pub Field\n) {\n    // reconstruct the commitment from the private nullfiers\n    let secret = Poseidon2::hash([id_nullifier, id_trapdoor], 2);\n    let id_commitment = Poseidon2::hash([secret], 1);\n\n    // compute the root of the merkle tree given the provided merkle merkle path\n    // and the reconstructed id commitment\n    // this can later be verified against a trusted root onchain or offchain\n    assert(root == compute_merkle_root(id_commitment, indices, siblings));\n\n    // the nullifier hash allows us to check how often a given identity signaled per topic\n    // every topic should use a distinct external nullifier\n    assert(nullifier_hash == Poseidon2::hash([external_nullifier, id_nullifier], 2));\n    assert(signal_hash * signal_hash == signal_hash * signal_hash);\n}\n\n#[test]\nfn test_hash() {\n    // check against circom poseidon implementation\n    assert(Poseidon2::hash([1, 2], 2) == 0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a);\n}\n","path":"/Users/zpedro/Documents/GitHub/semaphore-noir/packages/circuits/src/main.nr"}}}