---
sidebar_position: 3
title: Proofs
---

import Tabs from "@theme/Tabs"
import TabItem from "@theme/TabItem"

# Semaphore proofs

Once a user joins a [Semaphore group](/glossary#group) with their [Semaphore identity](/glossary#identity), the user can send their anonymous [message](/glossary#message) with a zero-knowledge proof that proves the following:

- the user is a member of the group,
- the same user created the message and the proof.

A unique [nullifier](/glossary#nullifier) is also generated for each proof that can be used to check whether that proof has already been validated.

## Install package

In your code, use the [`@semaphore-protocol/proof`](https://github.com/semaphore-protocol/semaphore/tree/main/packages/proof) package to generate and verify a proof.

<Tabs
  defaultValue="npm"
  groupId="package-managers"
  values={[
{label: 'npm', value: 'npm'},
{label: 'Yarn', value: 'yarn'},
{label: 'pnpm', value: 'pnpm'}
]}
>
  <TabItem value="npm">
    ```bash
    npm install @semaphore-protocol/proof
    ```
  </TabItem>

  <TabItem value="yarn">
    ```bash
    yarn add @semaphore-protocol/proof
    ```
  </TabItem>

  <TabItem value="pnpm">
    ```bash
    pnpm add @semaphore-protocol/proof
    ```
  </TabItem>
</Tabs>

:::info
Semaphore also provides `@semaphore-protocol/core`, which includes the functions of the following core packages: `@semaphore-protocol/identity`, `@semaphore-protocol/group`, `@semaphore-protocol/proof`.
:::

## Generate a proof

### 1. Create the identity

In order for a user to generate a proof, it is necessary to create a Semaphore identity. If you do not know how to
create an identity, see the previous [guide](/guides/identities) on identities.

### 2. Create the group

Before generating a proof you also need to create a Semaphore group containing the commitment of the Semaphore identity of the user who will generate the proof. If you do not know how to create a group, see the previous [guide](/guides/groups) on groups.

If your group is on-chain, you can use the [`@semaphore-protocol/data`](https://github.com/semaphore-protocol/semaphore/tree/main/packages/data) library to fetch the group members and re-create the off-chain group. For example:

```ts
import { SemaphoreSubgraph } from "@semaphore-protocol/data"
import { Group } from "@semaphore-protocol/group"

const semaphoreSubgraph = new SemaphoreSubgraph("sepolia")

const { members } = await semaphoreSubgraph.getGroup("42", { members: true })

const group = new Group(members)
```

### 3. Choose the scope

Each proof requires a [scope](/glossary#scope), on which each user may only generate one valid proof. The scope, together with the user's private key, is used to generate the nullifier, which is the value you can actually use to check whether a proof with that scope has already been generated by that user. In a voting application where double-voting must be prevented, the scope could be the ballot id, or the Merkle root of the group.

### 4. Generate the anonymous message

Finally, you can generate the proof with the anonymous message using the `generateProof` function. For example:

```ts
import { generateProof } from "@semaphore-protocol/proof"

const scope = group.root
const message = 1

const proof = await generateProof(identity, group, message, scope)
```

## Verify a proof

To verify a proof, pass the proof you generated to the `verifyProof` function. For example:

```ts
import { verifyProof } from "@semaphore-protocol/proof"

await verifyProof(proof) // true or false.
```

If you want to validate a proof on-chain, you can use [`@semaphore-protocol/contracts`](https://github.com/semaphore-protocol/semaphore/blob/main/packages/contracts) and the [`Semaphore.sol`](https://github.com/semaphore-protocol/semaphore/blob/main/packages/contracts/contracts/Semaphore.sol) contract, as explained in the previous [guide](/guides/groups#install-package-1), and use the `validateProof` function. For example:

```solidity
function validateProof(ISemaphore.SemaphoreProof calldata proof) external {
    semaphore.validateProof(groupId, proof);
}
```

## Memory management and bn128 curve termination

When working with Semaphore proofs, especially in Node.js environments, tests, or scripts, it's important to properly manage memory by terminating the bn128 elliptic curve when you're done using it. The curve operations use WebAssembly and require explicit cleanup to prevent memory leaks.

### Why is curve termination necessary?

Semaphore uses the bn128 (also known as BN254) elliptic curve for cryptographic operations through the `ffjavascript` library. This library creates WebAssembly instances that consume memory and need to be properly cleaned up when no longer needed.

Without proper termination:
- Memory leaks may occur in long-running applications
- Node.js processes might not exit cleanly
- Test suites may encounter memory issues

### When to terminate the curve

You should terminate the bn128 curve in the following scenarios:

- **Test environments**: After running tests that generate or verify proofs
- **Scripts and batch operations**: When your script finishes processing proofs
- **Server applications**: During application shutdown or when done with proof operations
- **Node.js applications**: Before process exit

### How to terminate the curve

Here's the recommended pattern for working with the bn128 curve:

```ts
import { getCurveFromName } from "ffjavascript"

let curve: any

async function setupCurve() {
    curve = await getCurveFromName("bn128")
}

async function cleanupCurve() {
    if (curve) {
        await curve.terminate()
    }
}

// Usage in your application
async function main() {
    try {
        await setupCurve()

        // Your proof generation/verification code here
        // const proof = await generateProof(...)
        // const isValid = await verifyProof(...)

    } finally {
        await cleanupCurve()
    }
}
```

### Example in test environments

Here's how to properly manage the curve in a test suite:

```ts
import { getCurveFromName } from "ffjavascript"
import { generateProof, verifyProof } from "@semaphore-protocol/proof"

describe("Semaphore Proofs", () => {
    let curve: any

    beforeAll(async () => {
        curve = await getCurveFromName("bn128")
    })

    afterAll(async () => {
        await curve.terminate()
    })

    it("should generate and verify a proof", async () => {
        const proof = await generateProof(identity, group, message, scope)
        const isValid = await verifyProof(proof)
        expect(isValid).toBe(true)
    })
})
```

### Best practices

1. **Always use try/finally blocks**: Ensure curve termination happens even if errors occur
2. **Terminate in cleanup hooks**: Use `beforeExit`, `SIGINT`, or similar process handlers
3. **One curve per application**: Reuse the same curve instance across multiple operations
4. **Don't forget in scripts**: Scripts should always terminate the curve before exiting

:::warning Important
Forgetting to terminate the bn128 curve can lead to memory leaks and prevent Node.js processes from exiting cleanly. Always ensure proper cleanup in your applications.
:::

:::tip
The Semaphore test suite demonstrates proper curve termination patterns. You can refer to the [test files](https://github.com/semaphore-protocol/semaphore/tree/main/packages/proof/tests) for examples of correct implementation.
:::
